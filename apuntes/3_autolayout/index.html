<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>Sesión 3: Autolayout</title>
	</head>
<body>
<h1>Sesión 3: Autolayout</h1>

<h2>Introducción</h2>

<p>El problema de colocar los elementos de la interfaz en unas coordenadas fijas es que si rota la pantalla o cambiamos de dispositivo, el interfaz no se va adaptar adecuadamente, ya que las dimensiones han cambiado y las coordenadas antes especificadas ahora pueden no tener sentido.</p>

<blockquote>
<p>Para que la previsualización del interfaz en Xcode tenga el mismo aspecto que las figuras, hay que desmarcar la casilla “Use size classes” del “File Inspector” (Área a la derecha de la pantalla, primer icono)</p>
</blockquote>

<p>Por ejemplo, supongamos que queremos centrar un botón en la pantalla, tanto vertical como horizontalmente. En principio parece que basta con moverlo con el ratón hacia el centro. En el momento que el botón está centrado, aparecen unas guías punteadas que nos lo indican.</p>

<figure><img src="center_guides_xcode.png"/></figure>

<p>Si ejecutamos la aplicación en el simulador veremos que efectivamente está centrado. Pero si rotamos la pantalla (tecla Cmd-Flecha izquierda) podremos ver que cuando cambia la resolución no es así.</p>

<figure><img src="noautolayout_portrait_landscape.png"/></figure>

<p>Necesitamos algún sistema que adapte automáticamente las dimensiones de los componentes de la interfaz a la resolución actual. En iOS ese sistema es <strong>Autolayout</strong>. Es un sistema declarativo y basado en restricciones. El sistema usa las restricciones especificadas para calcular automáticamente el <em>frame</em> de cada vista de la interfaz, y adaptarlo a las dimensiones actuales de la ventana.</p>

<h2>Manejo de restricciones con el Interface Builder</h2>

<p>Para especificar qué aspecto queremos que tenga la interfaz independientemente de la resolución hay que añadir <strong>restricciones</strong>. Básicamente las hay de dos tipos:</p>

<ul>
	<li><strong>De alineación</strong> (<em>align</em>): por ejemplo queremos que un botón esté centrado horizontalmente o verticalmente en su contenedor. O que varios componentes estén alineados entre sí.</li>
	<li><strong>De espaciado</strong> (<em>pin</em>): por ejemplo queremos que entre un componente y otro, o entre un componente y el borde izquierdo de la pantalla haya un espacio vacío. Aquí también se incluirían las restricciones de tamaño de un componente individual. (fijar el ancho, el alto,…)</li>
</ul>

<p>Hay dos formas de añadir restricciones en XCode: “haciendo clic y arrastrando” con el ratón o bien a través de la barra de herramientas de AutoLayout.</p>

<blockquote>
<p>Cuando se añaden restricciones de espaciado con respecto al borde superior e inferior de la pantalla, puede verse que en realidad no se están referenciando los bordes sino lo que Xcode llama <code>top layout guide</code> y <code>bottom layout guide</code>. La verdadera utilidad de estas guías es que se “mueven automáticamente” para dejar espacio a las barras de navegación y de botones que veremos cuando usemos <em>navigation controllers</em> y <em>tab bar controllers</em>, asegurándonos así de que dichas barras no tapan a nuestras vistas. </p>
</blockquote>

<h3>Añadiendo restricciones con botones/menús</h3>

<p>En la parte inferior derecha del <em>storyboard</em> hay una barra de botones específicos para autolayout</p>

<figure><img src="barra_autolayout.png"/></figure>

<p>Si queremos conseguir que funcione el ejemplo anterior en el que queríamos centrar horizontal y verticalmente el botón, pulsamos sobre el icono de <code>Align</code> (el primero), marcamos las casillas de <code>Horizontal center in container</code> y <code>Vertical center in container</code> y pulsamos sobre el botón que ahora pondrá <code>Add 2 constraints</code> para hacer efectivas las restricciones.</p>

<figure><img src="hv_center_autolayout.png"/></figure>

<p>Las líneas de guía, que antes aparecían punteadas, ahora serán continuas indicando que ahora son restricciones de autolayout. Dichas restricciones podemos verlas en varios sitios de Xcode:</p>

<ul>
	<li><p>En el área de <code>Document outline</code>, que es accesible pulsando sobre el icono <img src="Captura%20de%20pantalla%202014-10-15%20a%20la(s)%2018.03.41.png"/> que aparece en la parte inferior izquierda del <em>storyboard</em>. Aquí podemos ver un “árbol” desplegable con las restricciones. </p>

		<ul>
			<li>Si hacemos clic sobre una restricción, en el área de <code>Utilities</code> de la derecha de la pantalla, dentro del <code>Size inspector</code> (el pequeño icono con una regla <img src="Captura%20de%20pantalla%202014-10-15%20a%20la(s)%2018.09.58.png"/>) aparecerán sus propiedades, que podemos editar (luego veremos qué significan).</li>
			<li>Si hacemos clic sobre una restricción y pulsamos la tecla <code>Backspace</code> se eliminará.</li>
		</ul></li>
</ul>

<figure><img src="doc_outline_constraints.png"/></figure>

<ul>
	<li>Directamente en el <code>Size inspector</code> aparece una lista de restricciones. Cada una tiene un botón <code>Edit</code> para cambiar sus propiedades. </li>
</ul>

<p>Las mismas operaciones también las tenemos disponibles en la opción <code>Editor</code> del menú principal, a través de los submenús <code>Align</code> y <code>Pin</code>. </p>

<h3>Añadiendo restricciones con el ratón</h3>

<p>Esta forma es algo más ágil que la anterior pero requiere de cierta práctica. Cuando queremos establecer una restricción entre dos elementos <strong>arrastramos de uno a otro manteniendo pulsada la tecla <code>Ctrl</code></strong> (igual que para crear un <em>outlet</em> o un <em>action</em>). Cuando soltamos el botón del ratón, aparece un menú contextual donde elegir la restricción. </p>

<p>Las opciones disponibles en el menú dependen de la dirección y sentido en que se haya arrastrado: </p>

<ul>
	<li>Si arrastramos en sentido horizontal, podemos (entre otros) centrar verticalmente (aunque suene un poco a contrasentido). Y al contrario si arrastramos en vertical.</li>
	<li>Las restricciones de espaciado serán hacia el borde que hayamos arrastrado.</li>
</ul>

<h3>Restricciones insuficientes o contradictorias</h3>

<p>Generalmente cuando comenzamos a añadir restricciones, las líneas que las representan aparecen en color naranja en lugar de azul. Esto sucede porque todavía <strong>las restricciones son insuficientes</strong> para determinar unívocamente las coordenadas del <em>frame</em> del componente. Por ejemplo si acabamos de crear un botón y lo centramos verticalmente, lo hemos “fijado” en el eje de las <code>x</code> pero no así en el de las <code>y</code>. Además se muestra un contorno dibujado en línea punteada que indica dónde calcula Xcode que acabará posicionándose el componente con las restricciones actuales (y que muy probablemente no sea donde nosotros queremos).</p>

<p>Otro problema típico es <strong>mover el elemento una vez se ha establecido la restricción,</strong> de modo que no ocupa la posición que esta indica. Las líneas de restricción también aparecerán en naranja, y el número que indica su tamaño tendrá un símbolo <code>+</code> o <code>-</code> para indicar el desplazamiento.</p>

<p>Cuando <strong>las restricciones son contradictorias</strong>, las líneas que las representan aparecen en color rojo. Por ejemplo en la siguiente figura hemos intentado especificar un espaciado de 20 puntos con el margen derecho y simultáneamente que esté centrado en horizontal. Claramente esto es imposible, y así lo indica Xcode.</p>

<figure><img src="restricciones_contradictorias.png"/></figure>

<p>Cuando hay problemas con las restricciones estos se muestran también en el <code>Document outline</code> del storyboard. En el ángulo superior derecho del <code>Document outline</code> aparece una pequeña flecha roja indicando que hay problemas, y si la pulsamos aparecerá la lista de restricciones contradictorias e insuficientes.</p>

<p>Podemos intentar resolver estos problemas de forma automática. Para eso está el botón <code>Resolve autolayout issues</code> de la barra de botones de autolayout (recordar que está en la esquina inferior derecha del <em>storyboard</em>). Hay varias posibilidades:</p>

<ul>
	<li><code>Update frames</code>: queremos recalcular las posiciones y dimensiones de los <em>frames</em> usando las restricciones actuales. Si hemos movido los elementos con el ratón, volverán a “su posición”.</li>
	<li><code>Update restrictions</code>: si hemos movido los elementos, Xcode intentará recalcular las restricciones para que se correspondan con la posición actual.</li>
	<li><code>Add missing constraints</code>: basándose en la posición actual de los elementos, Xcode intentará inferir y añadir las restricciones adecuadas para que el <em>layout</em> deje de ser ambiguo.</li>
	<li><code>Reset to suggested constraints</code>: el equivalente a eliminar todas las restricciones (<code>Clear constraints</code>) y luego seleccionar <code>Add missing constraints</code>.</li>
</ul>

<h3>Previsualizar el efecto de las restricciones</h3>

<p>Aunque podemos visualizar el efecto de las restricciones ejecutando la aplicación en el simulador, es un proceso un poco tedioso, y más si queremos comprobar el aspecto en distintos dispositivos con distinto tamaño de pantalla. Tendríamos que ejecutar el simulador para cada uno de ellos. Desde Xcode 5 existe la posibilidad de previsualizar el aspecto de la interfaz (incluyendo por supuesto el autolayout). </p>

<p>Para previsualizar la interfaz, desde el editor del <em>storyboard</em> seleccionamos el <code>Assistant editor</code> (icono <img src="assistant_editor_icon.png"/> de la barra de herramientas). Como siempre sucede con este tipo de editor, el área principal se dividirá en 2. Si en la parte derecha no aparece la <em>preview</em>, la podemos seleccionar manualmente con los iconos de su zona superior</p>

<figure><img src="assistant_editor_preview_storyboard.png"/></figure>

<p>En la <em>preview</em> se ve el aspecto que va a tener la interfaz en un determinado hardware. En la parte inferior pone el nombre, por ejemplo “iPhone 4-inch”. Si pasamos el ratón por el nombre aparecerá a su izquierda un botón que sirve para rotar la pantalla.</p>

<figure><img src="hardware_storyboard_preview.png"/></figure>

<p>En la parte inferior izquierda de la ventana de <em>preview</em> hay un símbolo <code>+</code> que sirve para añadir otros modelos de dispositivo a la previsualización.</p>

<h3>Restricciones sobre el tamaño</h3>

<p>Aunque hemos dicho que autolayout calcula el <em>frame</em> de cada componente, hasta ahora hemos ignorado el tamaño de los mismos. Centrar en horizontal y vertical elimina la ambigüedad en cuanto a en qué coordenadas “anclar” el frame pero ¿qué hay de su ancho y alto?. </p>

<p>Para muchos componentes (<code>UILabel</code>, <code>UIButton</code>, <code>UIImage</code>) no es necesario especificar un tamaño ya que lo tienen por defecto (el llamado “tamaño intrínseco” en el argot de autolayout). En el API la propiedad correspondiente es <code>intrinsicContentSize</code>. Lo más habitual es que sea el tamaño del texto que contienen. </p>

<p>No obstante, también podemos poner restricciones sobre el tamaño. Podemos fijar el ancho y/o el alto o el <em>aspect ratio</em>. Estas son restricciones del tipo <code>pin</code> y por tanto las podemos encontrar donde encontramos las de espaciado entre componentes (en el menú principal o en la barra de botones de autolayout). Si usamos <code>ctrl-arrastrar</code> con el ratón bastará con que arrastremos sin salirnos del componente (al arrastrar en horizontal se nos dará la posibilidad de finar el ancho y lo mismo con el alto si arrastramos en vertical). </p>

<p>Si especificamos el tamaño mediante una restricción podemos forzar a que el contenido del botón tenga que “cortarse” porque no cabe, o bien que tenga que añadirse un <em>padding</em> al sobrar espacio. </p>

<h3>Más sobre las restricciones</h3>

<h4>Formulación completa de una restricción</h4>

<p>Internamente, cada restricción se formula como una ecuación lineal en la que:</p>

<pre><code>item1.atributo1 = multiplicador * item2.atributo2 + cte
</code></pre>

<p>Algunas restricciones no son ecuaciones sino <em>inecuaciones</em>, sustituyendo el símbolo <code>=</code> por <code>&lt;=</code> o <code>&gt;=</code>.</p>

<blockquote>
<p>Es decir, desde el punto de vista formal, lo que hace autolayout es resolver un sistema de ecuaciones lineales.</p>
</blockquote>

<p>Estas propiedades podemos verlas en el <code>Size inspector</code> (parte derecha de la pantalla, icono de la regla <img src="size_inspector.png"/>). Si seleccionamos un componente de UI aparecerán aquí todas sus restricciones, que podemos editar pulsando en <strong>Edit</strong>. Por ejemplo, aquí vemos las restricciones de un botón centrado en el eje de las X y con un espaciado estándar (8 puntos) con respecto a la guía inferior.</p>

<figure><img src="size_inspector_constraints.png"/></figure>

<p>Podemos observar en la figura las propiedades de la restricción, que se corresponden directamente con los coeficientes del lado derecho de la ecuación lineal (el multiplicador y la constante). Además aparece una <em>prioridad</em>, que explicaremos en el siguiente apartado. Haciendo clic en el desplegable con el símbolo <code>=</code> podemos cambiar la ecuación por una inecuación.</p>

<p>En nuestro ejemplo la constante es 0 y el multiplicador 1 porque queremos centrar el componente en el contenedor, es decir</p>

<pre><code>contenedor.centerX = componente.centerX
</code></pre>

<p>Podemos por ejemplo cambiar la constante por 50, con lo que conseguiremos que el componente esté desplazado 50 puntos a la izquierda de la posición de “centrado en X”.</p>

<p>Si en lugar de seleccionar el componente GUI seleccionamos directamente una restricción y nos vamos al <code>Size inspector</code> podremos editar directamente las propiedades de la restricción, incluyendo también los propios atributos.</p>

<h4>Prioridades</h4>

<p>Cada restricción tiene asignada una <strong>prioridad</strong>, que es un valor numérico que especifica su “importancia” (a mayor valor, mayor prioridad). El valor por defecto es 1000, que significa que el sistema entiende que la restricción <strong>debe cumplirse</strong>. Valores menores que 1000 indican que el sistema intentará cumplir la restricción pero que es posible que no lo haga si hay restricciones contradictorias de mayor prioridad.</p>

<p>Podemos cambiar/ver la prioridad actual de la misma forma que podemos cambiar/ver el resto de propiedades de la restricción (ver apartado anterior).</p>

<p>Además de las restricciones, también los componentes GUI tienen dos valores de prioridad, relativos al tamaño:</p>

<ul>
	<li><em>Compression resistance</em>: indica la prioridad que para el componente tiene mostrar completo su contenido (resistiéndose por tanto a ser comprimido, y de ahí el nombre. Por defecto los componentes tienen este valor alto (aunque menos que 1000, en Xcode 6 está fijado a 750). Si una regla con prioridad por defecto conlleva a que el contenido del botón no se vea completo ganará la regla, pero no será así si su prioridad es menor que 750.</li>
	<li><em>Content hugging</em>: indica la prioridad que para el componente tiene evitar el <em>padding</em>. Por defecto tiene un valor bajo, indicando que si hay reglas que lleven a aumentar el padding se tomarán en cuenta salvo que tengan prioridad muy baja.</li>
</ul>

<h2>Formular restricciones usando código</h2>

<p>En lugar de usar el editor visual del Interface Builder podemos especificar las restricciones en el código fuente. Esto puede resultar interesante en diversas situaciones: a veces los elementos de la interfaz se crean dinámicamente y por tanto no se puede especificar el <em>layout</em> en Xcode. Otras veces puede ser que aunque los elementos del interfaz no cambien sí queramos que cambien dinámicamente las restricciones para conseguir distintos efectos de <em>layout</em>.</p>

<p>Hay dos formas de hacerlo: directamente con el API de autolayout o con un mayor nivel de abstracción usando el llamado “Visual Format Language”. Si podemos elegir, la mejor forma es la segunda, ya que es mucho más intuitivo especificar las restricciones y entenderlas leyendo luego el código.</p>

<h3>El API básico de autolayout</h3>

<p>Cada restricción es un objeto de la clase <code>NSLayoutConstraint</code>. Para crearla se usa el método <code>constraintWithItem:…</code> que, como vamos a ver, especifica directamente parámetro por parámetro cada una de las propiedades de la restricción. Por ejemplo, supongamos que queremos centrar un componente (que tenemos en la variable <code>button</code>) en su contenedor (variable <code>superview</code>) en el eje de las X. La restricción sería algo como</p>

<pre><code>superview.centerX = 1*button.centerX+0
</code></pre>

<p>Donde se ha explicitado la constante y el multiplicador para ver más clara la correspondencia directa con el código, donde se haría como:</p>

<pre><code>NSLayoutConstraint *constraint = [NSLayoutConstraint 
  constraintWithItem:button
  attribute:NSLayoutAttributeCenterX
  relatedBy:NSLayoutRelationEqual
  toItem:superview
  attribute:NSLayoutAttributeCenterX
  multiplier:1.0
  constant:0.0]
</code></pre>

<p>Una vez creada la restricción para que tenga efecto hay que añadirla a la vista con <code>addConstraint</code></p>

<pre><code>[self.miBoton.superview addConstraint:constraint];
</code></pre>

<p>Como vemos, hemos añadido la restricción al contenedor del botón. Como norma general, si son vistas “madre/hija” la añadiremos a la “madre”, y en otro caso <em>al ancestro común más cercano de ambas vistas</em>. Por ejemplo si fuera una relación entre dos botones dentro del mismo contenedor la añadiríamos al contenedor.</p>

<h3>Visual Format Language</h3>

<p>La conversión de ecuación matemática a llamada del API es bastante directa, pero tiene el problema de que no es fácil y rápido deducir intuitivamente la restricción leyendo el código. Es mucho más intuitivo leer “el componente debe estar centrado en el eje X pero desplazado 10 pixels a la izquierda” que leer <code>superview.centroX = componente.centroX + 10</code>.</p>

<p>La descripción formal pero a la vez intuitiva de un conjunto de restricciones se puede hacer con una ingeniosa “representación en modo texto” de la representación gráfica de las restricciones llamada <em>Visual Format Language</em>. Dicho formato permite representar un conjunto de restricciones con una cadena de caracteres. La representación usa símbolos “semi-gráficos”, un poco al estilo del ASCII-ART (salvando las distancias). Así, por ejemplo si queremos especificar que entre dos componentes debe haber una separación estándar (8 pixels) usaríamos la cadena:</p>

<pre><code>[boton1]-[boton2]
</code></pre>

<p>Donde los corchetes indican un componente, y el <code>-`</code> indica la separación estándar. La cadena se parece razonablemente a la representación gráfica que podríamos ver en Xcode de la misma restricción.</p>

<p>Hay que indicar que <code>boton1</code> y <code>boton2</code> no son exactamente nombres de variables a diferencia de cuando usamos el API de <code>constraintWithItem:...</code>, sino etiquetas arbitrarias. </p>

<p>La llamada al API para crear esta restricción usando el <em>visual format language</em> sería algo como:</p>

<pre><code>[NSLayoutConstraint constraintsWithVisualFormat:
    @“[cancelButton]-[acceptButton]”
    options: NSLayoutFormatDirectionLeadingToTrailing | 
               NSLayoutFormatAlignAllCenterY 
    metrics:nil 
    views:viewsDictionary];
</code></pre>

<p>donde:</p>

<ul>
	<li>el primer parámetro es la cadena de formato, como un <code>NSString*</code></li>
	<li><code>options</code> es una máscara de bits formada a partir de enumerados describiendo la dirección y la alineación de los componentes</li>
	<li><code>metrics</code> se usa si hay constantes en la restricción (no es el caso del ejemplo). Es un diccionario en el que las claves son los nombres de las constantes y los valores son los de las constantes.</li>
	<li>el último, <code>views</code>, es un diccionario donde las claves son los nombres de componentes en la cadena y los valores son las variables correspondientes a las vistas. Habitualmente se usarán los mismos nombres, para simplificar, en cuyo caso podemos crear el diccionario automáticamente con <code>NSDictionaryOfVariableBindings</code>, al que le pasamos un número variable de argumentos con las variables de las vistas, por ejemplo:</li>
</ul>

<pre><code>UIButton *cancelButton = ...;
UIButton *acceptButton = ...;
NSDictionary *views = NSDictionaryOfVariableBindings(cancelButton, 
                         acceptButton);
</code></pre>

<p>Algunos ejemplos adicionales de cadenas de formato:</p>

<ul>
	<li><code>[boton1]-20-[boton2]</code> separación de 20 puntos</li>
	<li><code>[boton1(50)]-20-[boton2(&gt;=50)]</code> entre paréntesis especificamos el ancho del botón, nótese que se pueden poner desigualdades</li>
	<li><code>[boton1]-20@800-[boton2]</code> las prioridades se ponen con la <code>@</code></li>
	<li><code>[boton1]-20-[boton2(==boton1)]</code> el botón 2 debe ser del mismo tamaño que el 1.</li>
	<li><code>V:[topField]-10-[bottomField]</code> con la <code>V</code> especificamos que es un <em>layout</em> en vertical, los dos campos estarán uno encima del otro separados por una distancia de 10 puntos.</li>
	<li><code>|-[find]-[findNext]-[findField(&gt;=20)]-|</code>una línea completa de <em>layout</em>, donde las barras verticales representan los bordes del contenedor.</li>
</ul>

<p>Se recomienda consultar la documentación de Apple para más información sobre la sintaxis y ejemplos adicionales.</p>

<blockquote>
<p>En el diseño del formato, se ha preferido la claridad y el paralelismo con la representación gráfica a la expresividad. Como resultado, ciertas restricciones no son expresables. Por ejemplo no se puede especificar que el ancho de un botón sea el doble que el de otro.</p>
</blockquote>

<h2>Referencias</h2>

<ul>
	<li><p><a href="https://developer.apple.com/videos/wwdc/2012/">Videos de las sesiones</a> de la Apple WWDC 2012 (requieren un id. de Apple)</p>

		<ul>
			<li>Introduction to Auto Layout for iOS and OS X</li>
			<li>Best Practices for Mastering Auto Layout</li>
		</ul></li>
	<li><a href="http://www.raywenderlich.com/50317/beginning-auto-layout-tutorial-in-ios-7-part-1">Tutorial</a> de Ray Wenderlich</li>
	<li><a href="http://www.objc.io/issue-3/advanced-auto-layout-toolbox.html">Tutorial Avanzado</a> de Objc.io</li>
</ul>

</body>
</html>

